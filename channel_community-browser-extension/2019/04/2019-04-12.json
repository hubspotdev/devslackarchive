[
  {
    "poster": {
      "poster_name": "Jon McLaren",
      "poster_handle": "jon558"
    },
    "time_stamp": "2019-04-12 15:16:07",
    "text": "just brainstorming here. Just had a situation of someone else accidentally overwriting changes I made, because we both had the same file open in the design manager.\n\nI’ve always wanted to use the chrome extension to solve this atleast on an individual level - where the extension would know if you had another tab with the design manager open and would possibly alert you if you opened the same file in the other tab.\n\nI know of ways that could be done, but I was thinking if there was a way to do it at the multi-user level that’d be way more effective."
  },
  {
    "poster": {
      "poster_name": "Jon McLaren",
      "poster_handle": "jon558"
    },
    "time_stamp": "2019-04-12 15:26:51",
    "edited": {
      "time_stamp": "2019-04-12 15:28:22"
    },
    "text": "The other thing is I don’t really want to store this data somewhere, and if I had to do that to make it work, I’d want to make it so it was opt-in only.\n\nBasically 2 things would have to be stored/transmitted a portal id and a file id.\n\nI would not need to tye it to a user or anything like that.\n\nAnyone got ideas on how that could be done.\nI don’t want to have a database anywhere though handling that information. would rather it somehow be more peer 2 peer like you send an ID generated by the extension to eachother or something and it’d link your sessions or something. so there’s direct communication between your browsers using sockets or something no central database needed.\n\nIt would then “expire” once all users have closed out of the design manager."
  },
  {
    "poster": {
      "poster_name": "Jon McLaren",
      "poster_handle": "jon558"
    },
    "time_stamp": "2019-04-12 15:36:15",
    "text": "possible way this could work, though might get way complicated if you need to do this with more than 1 other person\n<https://peerjs.com>"
  },
  {
    "poster": {
      "poster_name": "dennis edson",
      "poster_handle": "dennis261"
    },
    "time_stamp": "2019-04-12 15:36:53",
    "text": "Is there a way to see modification date of a file in HS?"
  },
  {
    "poster": {
      "poster_name": "dennis edson",
      "poster_handle": "dennis261"
    },
    "time_stamp": "2019-04-12 15:37:59",
    "text": "Trying to think of how it would work"
  },
  {
    "poster": {
      "poster_name": "dennis edson",
      "poster_handle": "dennis261"
    },
    "time_stamp": "2019-04-12 15:38:21",
    "text": "Also, what happens if there was a more recent modification?"
  },
  {
    "poster": {
      "poster_name": "Jon McLaren",
      "poster_handle": "jon558"
    },
    "time_stamp": "2019-04-12 15:40:30",
    "text": "well my solution is actually not to deal with modification date"
  },
  {
    "poster": {
      "poster_name": "Jon McLaren",
      "poster_handle": "jon558"
    },
    "time_stamp": "2019-04-12 15:40:48",
    "text": "but to warn users when they open a file someone else in their group has open"
  },
  {
    "poster": {
      "poster_name": "Jon McLaren",
      "poster_handle": "jon558"
    },
    "time_stamp": "2019-04-12 15:41:06",
    "text": "or if they have another tab open with that file open in it"
  },
  {
    "poster": {
      "poster_name": "Jon McLaren",
      "poster_handle": "jon558"
    },
    "time_stamp": "2019-04-12 15:43:38",
    "text": "because it would prevent the problem to begin with not upon save.\n\nIt could even be adapted to  check if there are unpublished edits in the tab that was opened first, if not, then it wouldn’t throw a warning to the user who just opened the file, but would kick off a warning on publish to the user who first had it open “this file has been modifie, referesh”"
  },
  {
    "poster": {
      "poster_name": "Jon McLaren",
      "poster_handle": "jon558"
    },
    "time_stamp": "2019-04-12 15:47:51",
    "text": "Peerjs seems like it’s worth looking into even if it wont work for this use case.\n\nOne concern I have with trying to get it to work in the extension is google chrome’s permissions system may nuke it entirely because you normally have to pre-register any domains your extension will send/receive data to/from and well you can’t really do that with peer 2 peer"
  }
]