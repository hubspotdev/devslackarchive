[
  {
    "subtype": "thread_broadcast",
    "time_stamp": "2023-08-03 23:55:31",
    "text": "This is not possible at the moment, regardless of the type of serverless function you're running (beta projects / CMS ) ES modules and path/local dependency imports are unsupported.\n\n• CMS : Supports require of core node modules or the very old package versions of HubSpot/api-client, axios, request, and requests included with HubSpots custom lambda runtime.\n• beta projects : Supports require of core node modules, or any public npm dependency which must be declared in a package.json.\n*Solution to keep your source code clean and avoid copy/paste:* \nIn either case it is best to bundle your code before deploying, to keep things simpler I suggest you use esbuild or similar along with a script to copy your package.json/serverless.json files on build to the output directory of the build. googles wireit library is good for this as you can cache the results and only copy those if they change with a custom build script.\n\nFor beta projects, you may mark `packages:external` in the config to ignore dependencies when bundling with esbuild, thus HubSpot will get these modules for you and keep your build code smaller when viewing the build files on the projects management dashboard or within the dist directory of your IDE post build.\n\nFor CMS you will have to bundle absolutely everything. *The awesome part of learning this workflow is you can also use the same logic to bundle files for workflow actions. Thus sharring types, utility functions, internal modules, or whatever you need accross all your HubSpot deployed code without having to copy paste anything!*\n\n*Using Esbuild*\nTo keep things small and for your own DX I suggest coding ESM modules so that esbuild can do efficient treeshaking (remove unused imports and keep your output files nice and clean), in my tests so far it provides far smaller and more performant bundles than rollup.\n```// esbuild sample config for ESM =&gt; Bundled CJS\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  platform : 'node',\n  target : 'node18',\n  bundle: true,\n  // treeShaking: true, // implied by (bundle &amp;&amp; src.ext === 'mjs')\n  // mainFields : ['module,main'], // platform node implies main,module. Must be reversed to enable treeshaking if src is in ESM and they are set in pkg.json.\n  // format: \"cjs\", // implied by (platform === node &amp;&amp; bundle)\n  // conditions : ['node', 'module'], // implied by (platform === 'node'), module is included only if no custom conditions are explicitly set, used for when you have an \"exports\" field rather than \"main\" or \"browser\" in package.json\n  external : [\"axios\"], // platform node implies all core node modules will be marked external, omit any dependencies you don't want bundled\n  entryPoints: ['src/cms.functions/inspect-HubSpot-runtime-environment.mjs'], // add each cms function you want converted\n  outdir : \"dist\",\n  outbase : \"src\",\n  metafile: true,\n  logLevel: 'info'\n})```\n*The 'why' of unsupported require:* \nHubSpot serverless functions run on their own custom lambda implementation, their dependencies are likely provided via lambda layers for old CMS functions, or bundled for beta projects during the build. Either way your code goes through a proprietary build script which likely splits each function in the serverless.json into it's own lambda function, thus other files on your HubSpot file system do not exist in the environment your handler for the endpoint runs. This can be seen by the test function I wrote to inspect HubSpots environments.\n\nFunction output (shortened process.env log since it's got a lot of useless data for this demo)\n```{\n  \"fileName\": \"/var/task/test.js\",\n  \"cwd\": \"/var/task\",\n  \"ls\": [\n    \"HubSpotHandler.js\",\n    \"test.js\"\n  ],\n  \"env\": {\n    \"AWS_LAMBDA_FUNCTION_VERSION\": \"$LATEST\",\n    \"LAMBDA_TASK_ROOT\": \"/var/task\",\n    \"AWS_EXECUTION_ENV\": \"AWS_Lambda_nodejs18.x\",\n    \"PATH\": \"/var/lang/bin:/usr/local/bin:/usr/bin/:/bin:/opt/bin\",\n    \"PWD\": \"/var/task\",\n    \"LAMBDA_RUNTIME_DIR\": \"/var/runtime\",\n    \"NODE_PATH\": \"/opt/nodejs/node18/node_modules:/opt/nodejs/node_modules:/var/runtime/node_modules:/var/runtime:/var/task\",\n    \"_HANDLER\": \"HubSpotHandler.HubSpot_handler\"\n  }\n}```\nOf note my original function filename is inspectHSRuntimeEnv.js, what is running is test.js, and I never provided a HubSpotHundler.js, but this is where my code is sent when HubSpot builds that particular js file. The build deploy dashboard shows all my other defined functions, serverless.json, and even unused files. They just can't be accessed.\n\nThe original script used to generate these results is included here, you can use it to see the difference between your local runtime, and the one on the CMS by uncommenting the final log statement. Note this was not run through esbuild, it was something I wrote quickly just to test this myself a while back.\n\n```const fs = require('node:fs');\nconst logJSON = (x) =&gt; console.log(JSON.stringify(x, null, 2));\n\nexports.main = (context, sendResponse) =&gt; {\n  const fileName = __filename ?? false;\n  const cwd = __dirname ?? false;\n\n  if (fileName &amp;&amp; cwd) {\n    const ls = fs.readdirSync(cwd) ?? false\n\n    sendResponse({\n      statusCode: 200,\n      body: {\n        fileName,\n        cwd,\n        ls,\n        env: process.env\n      }\n    });\n    return;\n  }\n\n  sendResponse({\n    statusCode : 500,\n    body : 'Could not resolve __dirname or read the directory contents, check function log for details.'\n  })\n}\n\n// exports.main('', logJSON);```"
  }
]