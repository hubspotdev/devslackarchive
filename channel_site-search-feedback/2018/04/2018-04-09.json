[
  null,
  {
    "poster": {
      "poster_name": "Parker Short",
      "poster_handle": "parker"
    },
    "time_stamp": "2018-04-09 11:33:07",
    "text": "Where does one see the search analytics, if enabled? I didn’t see anything about it previously in here."
  },
  {
    "poster": {
      "poster_name": "Matt Coley",
      "poster_handle": "mcoley"
    },
    "time_stamp": "2018-04-09 11:36:50",
    "text": "We are working on adding that currently"
  },
  {
    "poster": {
      "poster_name": "Parker Short",
      "poster_handle": "parker"
    },
    "time_stamp": "2018-04-09 11:38:47",
    "text": "ah ok. Sounds good"
  },
  {
    "poster": {
      "poster_name": "Matt Coley",
      "poster_handle": "mcoley"
    },
    "time_stamp": "2018-04-09 11:39:33",
    "text": "Sorry about the delay. We wanted to get the basic functionality out there before google cut off access to their site search"
  },
  {
    "poster": {
      "poster_name": "Parker Short",
      "poster_handle": "parker"
    },
    "time_stamp": "2018-04-09 11:42:13",
    "text": "no worries. Just wanted to make sure I wasn’t missing anything."
  },
  {
    "poster": {
      "poster_name": "Parker Short",
      "poster_handle": "parker"
    },
    "time_stamp": "2018-04-09 11:44:00",
    "text": "<@U6GNQ7JBU> do you have to update the search params on both the search box and search results page? it looks like the params on the box only affect the auto-suggestions.",
    "reply_count": 5,
    "reply_users_count": 2,
    "replies": [
      {
        "time_stamp": "2018-04-09 11:51:57"
      },
      {
        "time_stamp": "2018-04-09 11:56:37"
      },
      {
        "time_stamp": "2018-04-09 11:57:18"
      },
      {
        "time_stamp": "2018-04-09 12:19:00"
      },
      {
        "time_stamp": "2018-04-09 12:27:20"
      }
    ]
  },
  {
    "poster": {
      "poster_name": "Matt Coley",
      "poster_handle": "mcoley"
    },
    "time_stamp": "2018-04-09 11:44:45",
    "text": "Let me ask the developer that works on the FE modules"
  },
  {
    "poster": {
      "poster_name": "Matt Coley",
      "poster_handle": "mcoley"
    },
    "time_stamp": "2018-04-09 11:45:34",
    "edited": {
      "time_stamp": "2018-04-09 11:45:40"
    },
    "text": "We have new versions of the modules that we are trying to push out that will allow you to set a custom search path in content settings"
  },
  {
    "poster": {
      "poster_name": "Parker Short",
      "poster_handle": "parker"
    },
    "time_stamp": "2018-04-09 11:47:29",
    "text": "oh cool. Would that let you have multiple search engine result pages? Blog search, directory search, etc."
  },
  {
    "poster": {
      "poster_name": "Anthony Pizzurro",
      "poster_handle": "anthonypizzurro"
    },
    "time_stamp": "2018-04-09 11:51:57",
    "text": "Hey Parker, can you give me some context around this? What updates to the params are you making?"
  },
  {
    "poster": {
      "poster_name": "Parker Short",
      "poster_handle": "parker"
    },
    "time_stamp": "2018-04-09 11:56:37",
    "text": "Sure. I was just limiting the results to site pages (no blogs)."
  },
  {
    "poster": {
      "poster_name": "Parker Short",
      "poster_handle": "parker"
    },
    "time_stamp": "2018-04-09 11:57:18",
    "text": "It looked like adjusting it on the search box only affected the search suggestions and didn’t get passed along to the results page"
  },
  {
    "poster": {
      "poster_name": "Matt Coley",
      "poster_handle": "mcoley"
    },
    "time_stamp": "2018-04-09 11:57:39",
    "text": "You will be able to set a custom search path for each subdomain. If you are hosting multiple content types under the same domain, you will soon be able to add query params to the search result page that will be pulled into to make the search API call. So you could add `type=BLOG_POST` or `type=SITE_PAGE` to only have those content types displayed under that domain. Additionally, there is nothing stopping you from building your own search pages utilizing the underlying search API using the default modules as a guide :slightly_smiling_face:"
  },
  {
    "poster": {
      "poster_name": "Parker Short",
      "poster_handle": "parker"
    },
    "time_stamp": "2018-04-09 12:01:06",
    "edited": {
      "time_stamp": "2018-04-09 12:01:24"
    },
    "text": "Gotcha. Any chance we’d be able to declare our own page types? I’m working on a directory off of HubDB and it’d be nice to only search things in that directory.",
    "reply_count": 13,
    "reply_users_count": 2,
    "replies": [
      {
        "time_stamp": "2018-04-09 12:02:41"
      },
      {
        "time_stamp": "2018-04-09 12:03:49"
      },
      {
        "time_stamp": "2018-04-09 12:12:33"
      },
      {
        "time_stamp": "2018-04-09 12:17:31"
      },
      {
        "time_stamp": "2018-04-09 12:22:46"
      },
      {
        "time_stamp": "2018-04-09 12:23:36"
      },
      {
        "time_stamp": "2018-04-09 12:23:37"
      },
      {
        "time_stamp": "2018-04-09 12:23:44"
      },
      {
        "time_stamp": "2018-04-09 12:23:46"
      },
      {
        "time_stamp": "2018-04-09 12:26:21"
      },
      {
        "time_stamp": "2018-04-09 12:29:23"
      },
      {
        "time_stamp": "2018-04-09 12:34:51"
      },
      {
        "time_stamp": "2018-04-09 12:46:47"
      }
    ]
  },
  {
    "poster": {
      "poster_name": "Matt Coley",
      "poster_handle": "mcoley"
    },
    "time_stamp": "2018-04-09 12:02:41",
    "text": "Interesting use case. I could add a query param to the API where you could specify a table id and it would only search for the dynamic pages for that table"
  },
  {
    "poster": {
      "poster_name": "Parker Short",
      "poster_handle": "parker"
    },
    "time_stamp": "2018-04-09 12:03:49",
    "text": "That would be amazing. We’re reworking a lot of website content and thinking about it more in “types” where a database makes sense."
  },
  {
    "poster": {
      "poster_name": "Matt Coley",
      "poster_handle": "mcoley"
    },
    "time_stamp": "2018-04-09 12:12:33",
    "text": ":+1: It would be interesting in the long term if you could create custom types based on filters"
  },
  {
    "poster": {
      "poster_name": "Parker Short",
      "poster_handle": "parker"
    },
    "time_stamp": "2018-04-09 12:17:31",
    "text": "Yes, definitely. I’m currently working on moving a pretty big team directory to HubDB, and being able to add in filters (locations, experience, specialties) would be a big win"
  },
  {
    "poster": {
      "poster_name": "Anthony Pizzurro",
      "poster_handle": "anthonypizzurro"
    },
    "time_stamp": "2018-04-09 12:19:00",
    "text": "Ah, gotcha! For right now, you’d need to update both the field and results modules. I’ll look at making that a little more seamless though"
  },
  {
    "poster": {
      "poster_name": "Matt Coley",
      "poster_handle": "mcoley"
    },
    "time_stamp": "2018-04-09 12:22:46",
    "text": "So essentially this: <https://developers.HubSpot.com/docs/methods/hubdb/get_table_rows> but with search functionality"
  },
  {
    "poster": {
      "poster_name": "Parker Short",
      "poster_handle": "parker"
    },
    "time_stamp": "2018-04-09 12:23:36",
    "text": "yep, pretty much"
  },
  {
    "poster": {
      "poster_name": "Matt Coley",
      "poster_handle": "mcoley"
    },
    "time_stamp": "2018-04-09 12:23:37",
    "text": "I can also add a query param to specify a hubdb query"
  },
  {
    "poster": {
      "poster_name": "Matt Coley",
      "poster_handle": "mcoley"
    },
    "time_stamp": "2018-04-09 12:23:44",
    "text": "to the search API"
  },
  {
    "poster": {
      "poster_name": "Parker Short",
      "poster_handle": "parker"
    },
    "time_stamp": "2018-04-09 12:23:46",
    "text": "that could work too"
  },
  {
    "poster": {
      "poster_name": "Parker Short",
      "poster_handle": "parker"
    },
    "time_stamp": "2018-04-09 12:26:21",
    "text": "Then you could filter after you get the results (I think)"
  },
  {
    "poster": {
      "poster_name": "Parker Short",
      "poster_handle": "parker"
    },
    "time_stamp": "2018-04-09 12:27:20",
    "text": ":+1:"
  },
  {
    "poster": {
      "poster_name": "Matt Coley",
      "poster_handle": "mcoley"
    },
    "time_stamp": "2018-04-09 12:29:23",
    "text": "What I was planning on doing is getting the row ids that match the query and filtering the results based on that ^"
  },
  {
    "poster": {
      "poster_name": "Matt Coley",
      "poster_handle": "mcoley"
    },
    "time_stamp": "2018-04-09 12:34:51",
    "text": "Shouldn't take too long to add"
  },
  {
    "poster": {
      "poster_name": "Parker Short",
      "poster_handle": "parker"
    },
    "time_stamp": "2018-04-09 12:46:47",
    "text": "very cool"
  },
  {
    "poster": {
      "poster_name": "Parker Short",
      "poster_handle": "parker"
    },
    "time_stamp": "2018-04-09 12:53:51",
    "text": "Is there any documentation around why certain search results are generated? e.g. since this isn’t a google CSE, I don’t expect it to work exactly like page rank, but it seems like the order on some search results are arbitrary. For example, result #1 is a page with the search term in it one time, but result #3 is a page with it 4 times and result #4 is a page with the term in the page title. Why?",
    "reply_count": 3,
    "reply_users_count": 2,
    "replies": [
      {
        "time_stamp": "2018-04-09 13:02:31"
      },
      {
        "time_stamp": "2018-04-09 13:03:35"
      },
      {
        "time_stamp": "2018-04-09 13:04:06"
      }
    ]
  },
  {
    "poster": {
      "poster_name": "Matt Coley",
      "poster_handle": "mcoley"
    },
    "time_stamp": "2018-04-09 13:02:31",
    "text": "I can write up a blog post on how we rank results but the gist of it is that we tokenize/analyze the search terms and perform td-idf on the index. We also parse different parts of the html into different fields and boost fields by different amounts. Finally we do log2p scoring adjustment based on how many views the page has gotten recently (the boost amount can be adjusted through the API)"
  },
  {
    "poster": {
      "poster_name": "Matt Coley",
      "poster_handle": "mcoley"
    },
    "time_stamp": "2018-04-09 13:03:35",
    "text": "I can expose the score through the API so you can see this better"
  },
  {
    "poster": {
      "poster_name": "Parker Short",
      "poster_handle": "parker"
    },
    "time_stamp": "2018-04-09 13:04:06",
    "text": "That’d be cool. I just know it’d be one of the first questions I get on a client project"
  },
  {
    "poster": {
      "poster_name": "Matt Coley",
      "poster_handle": "mcoley"
    },
    "time_stamp": "2018-04-09 14:31:07",
    "text": "You can query by tableId now: `<https://www.mattcoley.me/_hcms/search?term=stephen&amp;portalId=3787170&amp;minScore=0&amp;tableId=672738>`",
    "reply_count": 1,
    "reply_users_count": 1,
    "replies": [
      {
        "time_stamp": "2018-04-09 14:34:26"
      }
    ]
  },
  {
    "poster": {
      "poster_name": "Matt Coley",
      "poster_handle": "mcoley"
    },
    "time_stamp": "2018-04-09 14:34:26",
    "text": "Once your portal is reindexed"
  }
]