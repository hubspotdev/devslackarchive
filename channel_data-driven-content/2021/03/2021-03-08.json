[
  {
    "poster": {
      "poster_name": "Kieran",
      "poster_handle": "kieran073"
    },
    "time_stamp": "2021-03-08 01:34:25",
    "text": "Maybe try _onFormReady_"
  },
  {
    "subtype": "tombstone",
    "text": "This message was deleted.",
    "time_stamp": "2021-03-08 01:59:17",
    "reply_count": 1,
    "reply_users_count": 1,
    "replies": [
      {
        "time_stamp": "2021-03-08 06:58:30"
      }
    ]
  },
  {
    "poster": {
      "poster_name": "Gobi Selvaraj",
      "poster_handle": "gselvaraj"
    },
    "time_stamp": "2021-03-08 06:58:30",
    "text": "Are you trying to link HubDB table with Custom object?"
  },
  {
    "poster": {
      "poster_name": "Joel Gaudeul",
      "poster_handle": "joel.gaudeul"
    },
    "time_stamp": "2021-03-08 08:52:55",
    "text": "Hello, I'm looking to add some DEAL attributes in my Quotes custom template. Any clues on how to do it?\nFor a property with id \"end_of_trial_date\" I'm trying to display it with {{ DEAL_end_of_trial_date }}... without success. Any clue?"
  },
  {
    "poster": {
      "poster_name": "Jeff Main",
      "poster_handle": "jmain"
    },
    "time_stamp": "2021-03-08 13:39:48",
    "text": "Hi all! Question regarding filtering on what I imagine is a unique use case..? I have a client that has a large database of products in a HubDB table. Product names are stored as a text value within a column (i.e., \"FD-100, FD-101, FD-200, FD-202,\" and so on.) They'd like to filter by product name so we display just the 100s, or just the 200s, and so on. I know you cannot filter by text values, but I'm curious if there's a workaround here that can solve for this _without_ having to add a select column to the table. Is it possible to add products individually by name to a set, then run a for loop just on that set? Another method I'm not seeing? Any input is appreciated -- thanks in advance!",
    "reply_count": 6,
    "reply_users_count": 2,
    "replies": [
      {
        "time_stamp": "2021-03-08 15:25:25"
      },
      {
        "time_stamp": "2021-03-08 15:25:51"
      },
      {
        "time_stamp": "2021-03-08 15:27:20"
      },
      {
        "time_stamp": "2021-03-08 15:28:19"
      },
      {
        "time_stamp": "2021-03-08 16:13:58"
      },
      {
        "time_stamp": "2021-03-08 16:14:06"
      }
    ]
  },
  {
    "poster": {
      "poster_name": "Kieran",
      "poster_handle": "kieran073"
    },
    "time_stamp": "2021-03-08 15:25:25",
    "text": "Hey jeff - Maybe i’m not understanding, but I believe yo can do startswith in HubDB queries."
  },
  {
    "poster": {
      "poster_name": "Kieran",
      "poster_handle": "kieran073"
    },
    "time_stamp": "2021-03-08 15:25:51",
    "edited": {
      "time_stamp": "2021-03-08 15:26:08"
    },
    "text": "If the database is marked as public you can use AJAX (<https://developers.HubSpot.com/docs/api/cms/hubdb>) search for “startswith”"
  },
  {
    "poster": {
      "poster_name": "Kieran",
      "poster_handle": "kieran073"
    },
    "time_stamp": "2021-03-08 15:27:20",
    "text": "Or if you’re using HubL and hubdb_table_rows you can use\n```hubdb_table_rows(\"tablename\", \"fieldname__startswith=FD-\")```"
  },
  {
    "poster": {
      "poster_name": "Kieran",
      "poster_handle": "kieran073"
    },
    "time_stamp": "2021-03-08 15:28:19",
    "text": "From a relational database point of view, it usually would be cleaner to have a different column, but if this is what you have then it should be fine :slightly_smiling_face:"
  },
  {
    "poster": {
      "poster_name": "Jeff Main",
      "poster_handle": "jmain"
    },
    "time_stamp": "2021-03-08 16:13:58",
    "text": "Thank you Kieran! That will work in this case (though I agree with you, ordinarily, it would e easier to leverage a different column. :slightly_smiling_face: )"
  },
  {
    "poster": {
      "poster_name": "Jeff Main",
      "poster_handle": "jmain"
    },
    "time_stamp": "2021-03-08 16:14:06",
    "text": "appreciate the assist!"
  }
]