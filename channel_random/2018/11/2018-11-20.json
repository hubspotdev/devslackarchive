[
  null,
  null,
  {
    "poster": {
      "poster_name": "dennis edson",
      "poster_handle": "dennis261"
    },
    "time_stamp": "2018-11-20 07:59:59",
    "text": "<@UE5KKRMRR>, I am working on building a component library and researching approaches.  this one seemed pretty interesting.  as was fractal (<https://fractal.build/>)"
  },
  {
    "poster": {
      "poster_name": "ZhenXiaohui",
      "poster_handle": "smartdev8877"
    },
    "time_stamp": "2018-11-20 08:38:33",
    "text": "Are you developing a website now?"
  },
  {
    "poster": {
      "poster_name": "dennis edson",
      "poster_handle": "dennis261"
    },
    "time_stamp": "2018-11-20 08:53:40",
    "text": "Always, but this will be more of a general boilerplate component library so I can pull components and reuse on many sites"
  },
  {
    "poster": {
      "poster_name": "Mark Ryba",
      "poster_handle": "mryba"
    },
    "time_stamp": "2018-11-20 08:55:54",
    "text": "^ Be sure to report what you end up going with. I've been brainstorming the best way for us to create an internal component library as well. My initial thought was an NPM package with a series of importable template partials (we use pug in local development), but haven't had the time to do a deep dive into the best way forward"
  },
  null,
  {
    "poster": {
      "poster_name": "Chad Pierce",
      "poster_handle": "chadbluleadz"
    },
    "time_stamp": "2018-11-20 10:18:49",
    "text": "<@U26BLKGE4> How do you use Pug and Hubl at the same time?"
  },
  {
    "poster": {
      "poster_name": "Mark Ryba",
      "poster_handle": "mryba"
    },
    "time_stamp": "2018-11-20 10:37:42",
    "text": "tl;dr: We use them separately right now, but are working on automating the process\n\nWe don't necessarily... Our workflow right now is design key interior pages (Photoshop or Sketch), then once those are approved we create a static version of those key pages (using a build system that compiles into straight HTML, CSS, and JS) so that clients can see exactly how the site will look and feel across viewports. This also lets us be CMS agnostic during the design phase if necessary. Once those templates are approved by the client, that's when we start plugging in CMS code, be it HubL, WordPress PHP, or whatever fits the use-case best. However, I have been working on our build systems and SoP's to try and utilize a library of pug template partials (in the static development phase) that take the same arguments that will eventually be passed to HubSpot modules using a workflow inspired by React components. The end game there would be to build a CLI that would then compile those partials from pug into the CMS flavor we pick, ie \"cli build hubl\" and package those \"components\" into HS modules with minimum manual effort."
  },
  null,
  null,
  null,
  null
]