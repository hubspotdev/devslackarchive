[
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 07:51:05",
    "text": "Can interactive modules be used in production yet? In a dnd_area ?",
    "reply_count": 44,
    "reply_users_count": 3,
    "replies": [
      {
        "time_stamp": "2023-03-08 07:51:46"
      },
      {
        "time_stamp": "2023-03-08 07:52:05"
      },
      {
        "time_stamp": "2023-03-08 07:55:47"
      },
      {
        "time_stamp": "2023-03-08 07:56:09"
      },
      {
        "time_stamp": "2023-03-08 07:56:46"
      },
      {
        "time_stamp": "2023-03-08 07:57:16"
      },
      {
        "time_stamp": "2023-03-08 07:57:53"
      },
      {
        "time_stamp": "2023-03-08 07:58:17"
      },
      {
        "time_stamp": "2023-03-08 08:01:01"
      },
      {
        "time_stamp": "2023-03-08 08:02:10"
      },
      {
        "time_stamp": "2023-03-08 08:12:47"
      },
      {
        "time_stamp": "2023-03-08 08:13:29"
      },
      {
        "time_stamp": "2023-03-08 08:15:07"
      },
      {
        "time_stamp": "2023-03-08 08:15:54"
      },
      {
        "time_stamp": "2023-03-08 08:16:15"
      },
      {
        "time_stamp": "2023-03-08 08:16:34"
      },
      {
        "time_stamp": "2023-03-08 08:16:43"
      },
      {
        "time_stamp": "2023-03-08 08:19:04"
      },
      {
        "time_stamp": "2023-03-08 08:20:06"
      },
      {
        "time_stamp": "2023-03-08 08:25:38"
      },
      {
        "time_stamp": "2023-03-08 08:29:44"
      },
      {
        "time_stamp": "2023-03-08 08:30:19"
      },
      {
        "time_stamp": "2023-03-08 08:31:02"
      },
      {
        "time_stamp": "2023-03-08 08:31:18"
      },
      {
        "time_stamp": "2023-03-08 08:31:35"
      },
      {
        "time_stamp": "2023-03-08 08:31:40"
      },
      {
        "time_stamp": "2023-03-08 08:36:28"
      },
      {
        "time_stamp": "2023-03-08 08:38:04"
      },
      {
        "time_stamp": "2023-03-08 08:40:12"
      },
      {
        "time_stamp": "2023-03-08 08:42:29"
      },
      {
        "time_stamp": "2023-03-08 08:44:05"
      },
      {
        "time_stamp": "2023-03-08 08:44:14"
      },
      {
        "time_stamp": "2023-03-08 08:45:50"
      },
      {
        "time_stamp": "2023-03-08 08:46:34"
      },
      {
        "time_stamp": "2023-03-08 08:46:49"
      },
      {
        "time_stamp": "2023-03-08 08:46:59"
      },
      {
        "time_stamp": "2023-03-08 08:47:34"
      },
      {
        "time_stamp": "2023-03-08 08:48:29"
      },
      {
        "time_stamp": "2023-03-08 08:48:58"
      },
      {
        "time_stamp": "2023-03-08 08:49:03"
      },
      {
        "time_stamp": "2023-03-08 08:49:30"
      },
      {
        "time_stamp": "2023-03-08 08:50:10"
      },
      {
        "time_stamp": "2023-03-08 08:50:27"
      },
      {
        "time_stamp": "2023-03-08 08:51:09"
      }
    ]
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 07:51:46",
    "text": "I have a pretty straightforward scenario in mind. I need to make 1 http request, and then use state to search and filter data"
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 07:52:05",
    "text": "the request is non-authenticated/public"
  },
  {
    "poster": {
      "poster_name": "Timothy Finley",
      "poster_handle": "tfinley"
    },
    "time_stamp": "2023-03-08 07:55:47",
    "text": "JS module support for D&amp;D areas is really close. I believe using `{% dnd_module path=\"…/path/to/JS/module\" %}` will work now but there are bugs we are fixing to get the page editor support dragging in a D&amp;D module (I actually was coding fixes for that yesterday)"
  },
  {
    "poster": {
      "poster_name": "Timothy Finley",
      "poster_handle": "tfinley"
    },
    "time_stamp": "2023-03-08 07:56:09",
    "text": "Oh, by “interactive” you mean fetch data/API…"
  },
  {
    "poster": {
      "poster_name": "Timothy Finley",
      "poster_handle": "tfinley"
    },
    "time_stamp": "2023-03-08 07:56:46",
    "text": "Right now we still don’t have an avenue to fetch from an API inside the server rendering of a JS partial/module"
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 07:57:16",
    "text": "I can make the request before the module renders maybe and just pass in the data? I only need to make the request once"
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 07:57:53",
    "text": "and then I just need to be able to manipulate that data (filter/search based on form inputs)"
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 07:58:17",
    "text": "which I also see as the \"interactive\" part (whenever state is involved it's considered interactive?)"
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 08:01:01",
    "text": "I guess in other words, can I make the request outside of the island in the Component, and then just manipulate that data inside the Island?"
  },
  {
    "poster": {
      "poster_name": "Timothy Finley",
      "poster_handle": "tfinley"
    },
    "time_stamp": "2023-03-08 08:02:10",
    "text": "(brb)"
  },
  {
    "poster": {
      "poster_name": "Timothy Finley",
      "poster_handle": "tfinley"
    },
    "time_stamp": "2023-03-08 08:12:47",
    "text": "You certainly can make any fetches you want in browser/client, you’ll either need to:\n• Make that island “client only” so that it doesn’t render at all the server (since you don’t have the data yet)\n• Server the island on the server, but post hydration (`const afterHydration = useAfterIslandHydration()`) kick of the API request and use that to render additional HTML"
  },
  {
    "poster": {
      "poster_name": "Timothy Finley",
      "poster_handle": "tfinley"
    },
    "time_stamp": "2023-03-08 08:13:29",
    "text": "(Later when we support fetching data on the server you won’t have to be limited by that… there will be some other considerations then, but I’m mostly focusing on what you can do now)"
  },
  {
    "poster": {
      "poster_name": "Timothy Finley",
      "poster_handle": "tfinley"
    },
    "time_stamp": "2023-03-08 08:15:07",
    "text": "Note, `useAfterIslandHydration` is exported from `@HubSpot/cms-components` . And to make an Island “client only” you pass clientOnly to your Island `&lt;Island hydrateOn=\"...\" clientOnly=\"true\" …&gt;`"
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 08:15:54",
    "text": "that's great and definitely enough for what I need"
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 08:16:15",
    "text": "and otherwise, it will behave just like any module? I can add it between 2 other modules"
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 08:16:34",
    "text": "it's full width so nothing special is going on"
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 08:16:43",
    "text": "but does have to live on a dnd_area page"
  },
  {
    "poster": {
      "poster_name": "Timothy Finley",
      "poster_handle": "tfinley"
    },
    "time_stamp": "2023-03-08 08:19:04",
    "text": "When we’ve fixed the JS module D&amp;D area issues (soon :crossed_fingers:) from anyone outside the code the module will look and feel like a regular custom module built with HubL\n\n(Note, there is one subtlety about island IDs and making sure they don’t overlap if there are X of the same JS module on the page… so you don’t want to hardcode any island IDs inside the JS module. We may need to provide a little support/API there to make that easier, like providing the module instance name so you can build IDs on top of that)"
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 08:20:06",
    "text": "that's great. I'm going to give it a shot. Thanks for your help / insights"
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 08:25:38",
    "text": "<@UCY83QS6Q> sorry, just thought of an edge case. When the page loads, will I be able to grab url parameters? I guess that could happen outside the island? they could be passed in as initial values for the filter?"
  },
  {
    "poster": {
      "poster_name": "Timothy Finley",
      "poster_handle": "tfinley"
    },
    "time_stamp": "2023-03-08 08:29:44",
    "text": "It slightly depends. If the page is “prerendered” (there is no dynamic HubL getting contact details, graphql data, HubDB, etc)… then your JS module is only getting rendered once and cached so it will not see different URL query params.\n\nBut if the page _is_ dynamic (not prerendered) than you JS module will be rendered every load and can use the `usePageUrl` hook (returns a <https://developer.mozilla.org/en-US/docs/Web/API/URL|URL object>) on the server to “pre-fill” filter values."
  },
  {
    "poster": {
      "poster_name": "Timothy Finley",
      "poster_handle": "tfinley"
    },
    "time_stamp": "2023-03-08 08:30:19",
    "text": "(And usual note about performance of prerendered pages vs dynamically rendered pages… but for some use cases that is not or less of a concern)"
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 08:31:02",
    "text": "ok, yea, so it would be dynamic and clientOnly would be fine in this case"
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 08:31:18",
    "text": "it would be nice if the first render was server-side but that's not a huge deal"
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 08:31:35",
    "text": "I think I did that in my color palette generator app more or less"
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 08:31:40",
    "text": "so I have a rough idea of how that might work"
  },
  {
    "poster": {
      "poster_name": "Timothy Finley",
      "poster_handle": "tfinley"
    },
    "time_stamp": "2023-03-08 08:36:28",
    "text": "Great, let us know how else we can help (we do at least hope to get a few more of these APIs I’ve mentioned documented)"
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 08:38:04",
    "text": "`usePageUrl` is a HubSpot hook?"
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 08:40:12",
    "text": "yup (never mind)"
  },
  {
    "poster": {
      "poster_name": "Timothy Finley",
      "poster_handle": "tfinley"
    },
    "time_stamp": "2023-03-08 08:42:29",
    "edited": {
      "time_stamp": "2023-03-08 08:42:46"
    },
    "text": "Yup, the idea is `usePageUrl` does the server/client hydration “grunt work” for you, so you can get URL info without worrying about those details. i.e. it serializes the the URL that the server rendered with (even if that was some cached version without query params), makes sure the hydration render also uses that same server URL to prevent mismatches, and then kicks off another render post-hydration with the actual browser URL if that is different"
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 08:44:05",
    "text": "if I use clientOnly would it still work?"
  },
  {
    "poster": {
      "poster_name": "Timothy Finley",
      "poster_handle": "tfinley"
    },
    "time_stamp": "2023-03-08 08:44:14",
    "text": "Yup"
  },
  {
    "poster": {
      "poster_name": "Timothy Finley",
      "poster_handle": "tfinley"
    },
    "time_stamp": "2023-03-08 08:45:50",
    "edited": {
      "time_stamp": "2023-03-08 08:50:10"
    },
    "text": "Also `usePageUrl` listens for any popstate, pushstate, hashchange, or hashchange  events on the window. So if you are doing any routing/location changing in the browser, usePageUrl will automatically pick those changes up (depending on how you or the routing library changes the URL you may need to make sure one of those events are fired on location change, but that is pretty easy)"
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 08:46:34",
    "text": "cool, yea, I might actually need to do that. If I could change url along with filtered options that would be nice (but is not a requirement)"
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 08:46:49",
    "text": "it's more important that I can load a page with filter options set based on params in the url"
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 08:46:59",
    "text": "which it sounds like I can do"
  },
  {
    "poster": {
      "poster_name": "Ben Briggs",
      "poster_handle": "bbriggs"
    },
    "time_stamp": "2023-03-08 08:47:34",
    "edited": {
      "time_stamp": "2023-03-08 08:48:26"
    },
    "text": "&gt;  those events are fired on location change\nquick correction: there actually isn’t a built-in event for `pushState` so you may need to use the `pushHistoryState()` function we also export, where we wrap `pushState` with an event dispatch"
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 08:48:29",
    "edited": {
      "time_stamp": "2023-03-08 09:12:21"
    },
    "text": "that's good to know. I don't think I'll actually be doing any routing in that way"
  },
  {
    "poster": {
      "poster_name": "Ben Briggs",
      "poster_handle": "bbriggs"
    },
    "time_stamp": "2023-03-08 08:48:58",
    "text": ":+1: figured it was worth including for any future slack-searchers"
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 08:49:03",
    "text": "all of my data will load right away, then I want to either show all of it or some of it based on form filter values"
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 08:49:30",
    "text": "<@U04DVL5T2TE> yea, definitely, and I appreciate it too."
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 08:50:10",
    "text": "it's not a lot of data so I'm not worried about loading all of it"
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 08:50:27",
    "text": "but in the future it would definitely be nice to server render based on params in the url"
  },
  {
    "poster": {
      "poster_name": "Andrey Kondratyuk",
      "poster_handle": "andrey"
    },
    "time_stamp": "2023-03-08 08:51:09",
    "text": "don't know enough about server-side rendering to know if that's common or a big deal"
  }
]